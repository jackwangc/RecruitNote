# 网络知识汇总

## 浏览网页的原理

1. 客户端第一开始 没有 ip 地址，需要使用dhcp(动态主机配置协议) 获取，使用 udp 协议

2. 为了获取网关路由器的 mac 地址，使用 arp 协议(地址解析协议)，通过 ip 地址找到 mac 地址
   
3. 客户端浏览器通过 DNS (udp)解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。

4. 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。

5. 客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。

6. 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址

## 网络模型

- OSI七层模型
    
    物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

- TCP/IP四层协议

    网络接口层、 网际层、运输层、 应用层。

- TCP/IP五层协议

    物理层、数据链路层、网络层、运输层、 应用层

- 网络层常见设备和协议
    
    协议：ip协议(因特网互联协议)，arp协议(地址解析)
    设备：路由器

- 传输层

    协议：tcp(传输控制协议)和udp(用户数据报协议)
    设备：网关

- 应用层

    协议：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS

## tcp 和 udp

> 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文
（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多
的交互通信。
> 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控
制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据
块），每一条 TCP 连接只能是点对点的（一对一)

1. tcp 协议：ftp,http,telnet,pop3
2. udp 协议：dns,dhcp(动态主机配置协议)

### tcp

三次握手

> 为什么三次握手，防止失效的请求到达服务器，让服务器错误的打开连接。（连接请求在网络中滞留，客户端等待超时，重新请求，之前连接失效）

1. 服务器处于监听状态，等待客户的连接请求
2. 客户端向服务器发送请求报文，syn = 1,ack = 0,初始序号 x;
3. 服务器接收到连接请求报文，如果同意建立连接，向客户端发送确认报文，syn = 1,ack = 1,确认号 x+1,同时也选择一个初始的序号 y
4. 客户端收到服务器的连接确认报文后，还要向服务器进行确认，确认号为 y+1,序号为 x+1

四次握手

> 为什么需要四次握手：传递未发送完的数据。客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服
务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。
1. 客户端发送连接释放报文，fin = 1
2. 服务端收到以后确认，此时 tcp 处于半关闭状态，服务器能向客户端发送数据，但是客户端不能向服务器发送数据
3. 服务器不需要再连接时，发送连接释放报文
4. 客户端收到后发出确认，进入 time-wait 状态，等待 2msl 后释放连接
5. 服务器收到客户端的确认后，释放连接

## socket

## dns ip

> 当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。

## http 和 https

### http

> HTTP协议全称Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于TCP/IP四层模型当中的应用层。默认80端口

1. 传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。
2. HTTP协议通过请求/响应的方式，在客户端和服务端之间进行通信
3. HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”

#### http 请求过程

1. 客户端连接到 Web 服务器
    1. 一个 HTTP 客户端， 通常是浏览器， 与 Web 服务器的 HTTP 端口（默认为 80） 建立一个 TCP 套接字连接。 例如， http://www.oakcms.cn。
2. 发送 HTTP 请求
    1. 通过 TCP 套接字， 客户端向 Web 服务器发送一个文本的请求报文， 一个请求报文由请求行.   请求头部.   空行和请求数据 4 部分组成。
3. 服务器接受请求并返回 HTTP 响应
    1. Web 服务器解析请求， 定位请求资源。 服务器将资源复本写到 TCP 套接字， 由客户端读取。 一个响应由状态行.   响应头部.   空行和响应数据 4 部分组成。
4. 释放连接 TCP 连接
   1. 若 connection 模式为 close， 则服务器主动关闭 TCP 连接， 客户端被动关闭连接，释放 TCP 连接;若 connection 模式为 keepalive， 则该连接会保持一段时间， 在该时间内可以继续接收请求;
5. 客户端浏览器解析 HTML 内容

#### 对称加密方式

> 对称加密方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。

> 但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。

1. 服务端把加密方式和密钥传递给客户端(加密方式和密钥是明文)
2. 客户端接收加密信息
3. 加密通信明文，开始进行传递
4. 对称加密算法：AES，RC4，3DES
5. HASH算法：MD5，SHA1，SHA256

#### 非对称加密

> 非对称加密，为密钥的传输做一层额外的保护。非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密
 
1. 服务端和客户端建立通信，服务端首先把自己的公钥 Key1 发给客户端：
2. 接收到服务端公钥，客户端自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密（这里有点绕），发送给服务端：
3. 服务端利用自己非对称加密的私钥，解开了公钥Key1的加密，获得了Key2的内容。从此以后，客户端和服务端就可以利用 Key2进行对称加密的通信了
4. 破解流程：
5. 截获服务端的公钥Key1，自己另外生成一对公钥私钥，
6. 把自己的公钥Key3发送给客户端。然后破解出客户端传递过来的 key2,
7. 利用key1 加密 key2,发送给服务端，中间人就可以解密信息
8. 非对称加密算法：RSA，DSA/DSS

### https

> 引入第三方，一个权威的证书颁发机构（CA）来解决。证书一般包括证书颁发机构，服务端网址，服务端公钥（机构私钥加密），证书签名（机构私钥加密），默认 443端口

https 在 http 的基础上增加了 ssl 安全层，认证流程在 ssl 层中完成，ssl 属于传输层

1.  服务端把公钥 key1 发给证书办法机构，申请证书
2.  机构利用自己的私钥加密服务端公钥 key1
3.  通过服务端网址等信息生成证书签名，并通过私钥加密
4.  机构把证书发给服务端
5.  客户端请求通信，服务端将证书传给客户端
6.  客户端通过浏览器和操作系统找到本地的证书机构名称和机构的公钥
7.  解密证书签名
8.  客户端向机构请求生成证书签名，和本地接受证书签名比较
9.  证书签名一致，证书有效，利用机构公钥解密服务端公钥 key1
10. 利用公钥 key1 加密客户端生成的对称加密密钥 key2
11. 发送给服务端
12. 服务端通过 key1 的私钥解密，得到对称加密密钥 key2.
13. 客户端和服务端开始利用 key2 进行对称加密的通信


## session cookie

> HTTP协议是一种"无状态"协议，客户浏览器与服务器建立连接，发出请求，得到相应，然后关闭连接，这意味着每次客户端检索网页时，客户端打开一个单独的连接到 Web 服务器，服务器会自动不保留之前客户端请求的任何记录。因此用户需要一个唯一会话 id

### cookie

> Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式，也可以跟踪用户信息

### session

> Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中

### 区别

1. session 在服务器端，cookie 在客户端（浏览器）
2. session 默认被存在在服务器的一个文件里（不是内存）
3. session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
4. session 可以放在 文件、数据库、或内存中都可以。
5. 用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id

## socket

> Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议

> 端口号时用来区分进程的，这样 ip 层传过来的数据到达 tcp 后就可以分给各个程序

### udp socket 编码

发送方

1. 首先创建udp的socket服务

2. 将需要发送的数据放在数据包DatagramSocket中，DatagramSocket会根据UDP协议对数据包、IP、端口号进行封装

3. 通过udp的socket服务将数据包发送

4. 最后将udp服务关闭

接受方

1. 创建udp的socket服务，并且明确自己的端口号

2. 创建DatagramSocket用来解析数据接收到的数据包

3. 将数据接收到数据包DatagramSocket中

4. 通过DatagramSocket解析数据

5. 关闭服务

### tcp socket 编码

客户端

1. 首先创建一个Socket和InetSocketAddress 
2. 然后通过Socket的connect()方法进行连接
3. 连接成功后可以获取到输出流
4. 通过该输出流就可以向服务端传输数据。

服务端

1. 首先创建一个服务端Socket并明确端口号
2. 通过accept()方法获取到链接过来的客户端Socket
3. 从客户端Socket中获取输入流，最后由输入流读取客户端传输来的数据。


## WebSocket

> websocket是HTML5的一个新协议，它允许服务端向客户端传递信息，实现浏览器和客户端双工通信,服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话

1. http 只允许 客户端向服务端发送数据
2. 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 
3. 建立在TCP协议基础之上，和http协议同属于应用层数据格式比较轻量，性能开销小，通信高效。(没有http臃肿的头部)
4. 可以发送文本，也可以发送二进制数据。 
5. 没有同源限制，客户端可以与任意服务器通信协议标识符是ws（如果加密，则为wss），服务器网址就是 URL,如ws://localhost:8023

## ajax

> 指一种创建交互式网页应用的网页开发技术。客户端与服务器，可以在【不必刷新整个浏览器】的情况下，与服务器进行异步通讯的技术

实现流程

1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象.
2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
3. 设置响应HTTP请求状态变化的函数.
4. 发送HTTP请求.
5. 获取异步调用返回的数据.
6. 使用JavaScript和DOM实现局部刷新.

---
## 参考链接

1. [小灰https](https://mp.weixin.qq.com/s/1ojSrhc9LZV8zlX6YblMtA)
2. [socket编程](https://mp.weixin.qq.com/s/UD5S-MTF4ic6NZmW4ZZaxQ)