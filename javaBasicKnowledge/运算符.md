# 运算符

## `++`

```java
// 1. 自增前缀；前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算
++a;
// 2. 自增后缀；后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算 实例
a++;
// 3. i++语句是需要一个临时变量取存储返回自增前的值，而++i不需要。
// 这样就导致使用i++时系统需要先申请一段内存空间，然后将值赛进去，最后不用了才去释放

// 使用场景
// 1.单独使用
// 都会自增+1
i++
++i
// 2.for循环
// 没有区别
for(i++ == ++i){

}
int i = 0; // Initialization

loopStart:
if (i < 5) // Condition
{
   Output(i);

   i++ or ++i; // Increment

   goto loopStart;
}
// 3.表达式变量,方法参数
// 存在区别 a++先取值再加1
// ++a 先取值 再加1
add(i++)!= add(++i)


// 4.不使用返回值没有区别
i = 3
i++
i = 4
i++ = 3

++i
i=4
++i =4
```

## java 移位运算符

> 从效率上看，使用移位指令有更高的效率，因为移位指令占2个机器周期，而乘除法指令占4个机器周期。从硬件上看，移位对硬件更容易实现，所以会用移位，移一位就乘2,这种乘法当然考虑移位了。

操作符 | 描述 | 例子
---|---|---
`<<` | 按位右移 | `a << 2` ,二进制左移两位
`>>` | 按位左移 | `b >> 16`,二进制右移16位

1. [参考](https://zhuanlan.zhihu.com/p/26890617)
## java 取整 取余

### 取整

```java
int a = 10;
int b = 3;

int c = a / b; // 取整 =3

```

### 取余

```java
int a = 10;
int b = 3;
int f = a % b; // 取余 = 1
int j = b % a; // 取余 = 3
```

## equals 和 ==

### ==

1. 在java中“==”是用来比较变量值是否相等。如果是基本类型，直接比较值。如果是对象类型，比较的是两个对象的引用，也就是地址。对象是放在堆中的，栈中存放的是对象的引用。“==”是对栈中的值进行比较的

2. 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。

### equals

1. java所有的类都是集成自Object类，Object里有一个方法“equals”，这个方法是用来比较两个对象是否相等的。

2. 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。

### hashCode

> HashCode是用于查找使用的，而equals是用于比较两个对象是否相等的。

特性

1. HashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，HashCode经常用于确定对象的存储地址；

2. 如果两个对象相同， equals方法一定返回true，并且这两个对象的HashCode一定相同；

3. 两个对象的HashCode相同，并不一定表示两个对象就相同，即equals()不一定为true，只能说明这两个对象在一个散列存储结构中。

4. 如果对象的equals方法被重写，那么对象的HashCode也尽量重写

作用

> 从Object角度看，JVM每new一个Object，它都会将这个Object丢到一个Hash表中去，这样的话，下次做Object的比较或者取这个对象的时候（读取过程），它会根据对象的HashCode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。若HashCode相同再去调用equal。

1. 我们先通过 HashCode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过equals在这个桶里找到我们要的类。 
2. 查找时效率提高

重写 equals 要重写 hashcode

1. 默认调用 Object 的 hashcode 方法，该方法比较的对象的存储地址。
2. 虽然两个对象的HashCode相等，但是实际上两个对象并不是相等，因为我们没有重写equals方法，那么就会调用Object默认的equals方法，显示这是两个不同的对象。



