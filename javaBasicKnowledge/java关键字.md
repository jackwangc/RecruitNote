# java 关键字

## this

1. 代表对象。就是所在函数所属对象的引用。哪个对象调用了this所在的函数，this就代表哪个对象
2. this是方法（除静态方法外）中存在的隐式参数，所以在方法中使用this
3. 注意：this调用构造函数，必须在构造函数的第一行。否则编译失败。
4. this不能用于static修饰的方法

## super

> super 关键字用以访问父类成员

1. 使用 super 关键字， super 代表父类对象
2. super 只能出现在子类的方法和构造方法中
3. 调用构造方法是，必须是第一句
4. super 不能访问父类的 private 成员

## static

> 关键字，是一个修饰符，用于修饰成员（成员变量和成员函数）

1. 在类中，用static声明的成员变量为静态变量，或者叫做：类属性，类变量，从属于类，
2. 给对象分配的内存里没有它为类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显示初始化
3. 用static声明的方法为静态方法
4. 在调用该方法时，不会将对象的引用传递给它，所以在static方法中，不可访问非static的成员
5. 在静态方法中，不能用this和supper关键字

## final

> 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量

1. 对于基本类型，final 使数值不变；
2. 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的

## volatile

> Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他 线程，不保证原子性

1. 两种特性保证 volatile 类型的变量总会返回最新的值
   1. 变量可见性
      1. 如何保证可见性： 每次访问变量时进行一次刷新，每次访问的都是主内存中的最新版本
   2. 禁止重排序
2. 比 synchronized 更轻量级的同步锁，因为不会执行加锁操作，因此不会使线程阻塞
3. 使用场景，一个变量被多个线程共享，线程直接给这个变量赋值
4. 能够替代 synchronized 的情况
   1. 或者说是单纯的变量赋值
   2. 只有在状态真正独立于程序内其他内容时才能使用 volatile

5. 变量已经在 synchronized 中，没必要使用
6. 屏蔽了 JVM 优化，效率比较低，要减少使用。 

## synchronized

> synchronized可以保证方法或代码块在运行时，同一时刻只有一个线程可以进入到临界区（互斥性），同时它还保证了共享变量的内存可见性

1. synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁
2. synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线 程加锁消耗的时间比有用操作消耗的时间更多
3. Synchronized是非公平锁。 Synchronized在线程进入ContentionList时，等待的线程会先 尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是 不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁 资
4. 核心组件

