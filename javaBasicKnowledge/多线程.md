# 多线程

## 多线程java操作

1. [java多线程操作](多线程java实现.java)

## java 内存模型（线程）

![内存模型](../picture/java内存线程.png)

1. 线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。
2. Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作
    1. read：把一个变量的值从主内存传输到工作内存中
    2. load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
    3. use：把工作内存中一个变量的值传递给执行引擎
    4. assign：把一个从执行引擎接收到的值赋给工作内存的变量
    5. store：把工作内存的一个变量的值传送到主内存中
    6. write：在 store 之后执行，把 store 得到的值放入主内存的变量中
    7. lock：作用于主内存的变量
    8. unlock

### 内存模型特性

1. 原子性
   1. 原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉 
   2. 内存模型中的单个操作具有原子性
   3. 保证原子性
      1. 使用原子类 `private AtomicInteger cnt = new AtomicInteger();` 
      2. 使用 synchronized 互斥锁来保证操作的原子性
   
2. 可见性
   1. 可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改
   2. 保证可见性
      1. volatile，volatile 并不能保证多次操作的原子性。(单个操作本身具有原子性)
      2. synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
      3. final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。
3. 有序性
   1. 在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，
   2. volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。
   3. 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码

## 线程安全

> 多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为

实现方式

1. 不可变
   1. 不可变（Immutable）的对象一定是线程安全的，
   2. 不可变类型：final,String,枚举类型
2. 互斥同步(悲观锁)
   1. synchronized 
   2. ReentrantLock
   3. 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。
   4. 无论共享数据是否真的会出现竞争，它都要进行加锁

3. 非阻塞同步(乐观锁)(无锁策略)
   1. 互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步
   2. 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。
   3. 乐观锁需要操作和冲突检测这两个步骤具备原子性
   4. 这里就不能再使用互斥同步来保证了，只能靠硬件来完成
   5. J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。

4. 无同步方案
   1. 要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性
   2. 实现：
      1. 栈封闭，多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。
      2. 线程本地存储功能，这些共享数据的代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内
      3. 可重入代码，以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）

## CAS

> 而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，这项CAS技术就是无锁策略实现的关键，下面我们进一步了解CAS技术的奇妙之处。

1. CAS 的思想很简单：三个参数，一个当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false
2. Unsafe，是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe 相当于一个后门，基于该类可以直接操作特定内存的数据。
3. 处理过程
   1. AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据 Java 内存模型，线程 A 和线程 B 各自持有一份 value 的副本，值为 3。
   2. 线程 A 通过getIntVolatile(var1, var2)拿到 value 值 3，这时线程 A 被挂起。
   3. 线程 B 也通过getIntVolatile(var1, var2)方法获取到 value 值 3，运气好，线程 B 没有被挂起，并执行compareAndSwapInt方法比较内存值也为 3，成功修改内存值为 2。
   4. 这时线程 A 恢复，执行compareAndSwapInt方法比较，发现自己手里的值 (3) 和内存的值 (2) 不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。
   5. 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总是能够看到，线程 A 继续执行compareAndSwapInt进行比较替换，直到成功。 
4. 缺点
   1. CAS 存在一个很明显的问题，即 ABA 问题
   2. 当修改为本身时，如果判定是否被修改过
   3. java 并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证 CAS 的正确性。

### 参考文章

1. [无锁CAS](https://blog.csdn.net/javazejian/article/details/72772470)
2. [深入浅出Cas](https://www.jianshu.com/p/fb6e91b013cc)

##  volatile 和 synchronized

### volatile

> Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他 线程，不保证原子性

1. 两种特性保证 volatile 类型的变量总会返回最新的值
   1. 变量可见性
      1. 如何保证可见性： 每次访问变量时进行一次刷新，每次访问的都是主内存中的最新版本
   2. 禁止重排序
2. 比 synchronized 更轻量级的同步锁，因为不会执行加锁操作，因此不会使线程阻塞
3. 使用场景，一个变量被多个线程共享，线程直接给这个变量赋值
4. 能够替代 synchronized 的情况
   1. 或者说是单纯的变量赋值
   2. 只有在状态真正独立于程序内其他内容时才能使用 volatile

5. 变量已经在 synchronized 中，没必要使用
6. 屏蔽了 JVM 优化，效率比较低，要减少使用。 

### synchronized

> synchronized可以保证方法或代码块在运行时，同一时刻只有一个线程可以进入到临界区（互斥性），同时它还保证了共享变量的内存可见性

1. synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁
2. synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线 程加锁消耗的时间比有用操作消耗的时间更多
3. Synchronized是非公平锁。 Synchronized在线程进入ContentionList时，等待的线程会先 尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是 不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁 资
4. 核心组件

#### 实现

1. 

#### 参考链接

1. [java volite解惑](https://www.jianshu.com/p/195ae7c77afe)
2. [volite深入](https://www.jianshu.com/p/506c1e38a922)
3. [深入浅出 synchronized](https://www.jianshu.com/p/19f861ab749e)

## 锁优化

> 这里的锁优化主要是指 JVM 对 synchronized 的优化。

1. 自旋锁
   1. 自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态

2. 锁消除
   1. 锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除  
   2. 锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待

3. 锁粗化
   1. 如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗
   2. 如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部

4. 轻量级锁
   1. 轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销
   2. 在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步

5. 偏向锁
   1. 偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要


## 线程池

> 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务

1. [线程池的使用](https://www.cnblogs.com/dolphin0520/p/3932921.html)
---
参考书目

1. [多线程聚合](https://mp.weixin.qq.com/s/etsUQKfqWvozUONB7Fqn2w）
2. [java并发专题](https://blog.csdn.net/javazejian/article/category/6940462)