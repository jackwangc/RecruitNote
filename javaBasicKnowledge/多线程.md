# 多线程

## 多线程java操作

1. [java多线程操作](多线程java实现.java)

## java 内存模型（线程）

![内存模型](../picture/java内存线程.png)

1. 线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。
2. Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作
    1. read：把一个变量的值从主内存传输到工作内存中
    2. load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
    3. use：把工作内存中一个变量的值传递给执行引擎
    4. assign：把一个从执行引擎接收到的值赋给工作内存的变量
    5. store：把工作内存的一个变量的值传送到主内存中
    6. write：在 store 之后执行，把 store 得到的值放入主内存的变量中
    7. lock：作用于主内存的变量
    8. unlock

### 内存模型特性

1. 原子性
   1. 原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉 
   2. 内存模型中的单个操作具有原子性
   3. 保证原子性
      1. 使用原子类 `private AtomicInteger cnt = new AtomicInteger();` 
      2. 使用 synchronized 互斥锁来保证操作的原子性
   
2. 可见性
   1. 可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改
   2. 保证可见性
      1. volatile，volatile 并不能保证操作的原子性。
      2. synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
      3. final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。
3. 有序性
   1. 在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，
   2. volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。
   3. 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码

## 线程安全

> 多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为

实现方式

1. 不可变
   1. 不可变（Immutable）的对象一定是线程安全的，
   2. 不可变类型：final,String,枚举类型
2. 互斥同步
   1. synchronized 
   2. ReentrantLock
   3. 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。
   4. 无论共享数据是否真的会出现竞争，它都要进行加锁

3. 非阻塞同步
   1. 互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步
   2. 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。
   3. 乐观锁需要操作和冲突检测这两个步骤具备原子性
   4. 这里就不能再使用互斥同步来保证了，只能靠硬件来完成
   5. J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。

4. 无同步方案
   1. 要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性
   2. 实现：
      1. 栈封闭，多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。
      2. 线程本地存储功能，这些共享数据的代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内
      3. 可重入代码，以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）

## CAS

##  Volatile 和 synchronized

## 锁优化

> 这里的锁优化主要是指 JVM 对 synchronized 的优化。

1. 自旋锁
   1. 自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态

2. 锁消除
   1. 锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除  
   2. 锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待

3. 锁粗化
   1. 如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗
   2. 如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部

4. 轻量级锁
   1. 轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销
   2. 在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步

5. 偏向锁
   1. 偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要


## 线程池

> 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务
---
参考书目

1. [多线程聚合](https://mp.weixin.qq.com/s/etsUQKfqWvozUONB7Fqn2w）
2. 