# 面向对象

## 封装

将对象的状态信息(eg:Person对象的age变量)隐藏在对象内部，外部程序只能通过该类提供的方法来实现对内部信息的操作和访问。（getter and setter）

## 继承

> 继承就是子类继承父类的特征和行为，使得子类具有父类的各种属性和方法（重用父类代码）。

1. 类是对对象的抽象，继承是对某一批类的抽象，从而实现对现实世界到更好的建模
2. 提高代码的复用性
3. extends的意思是"扩展"，子类是父类的扩展
1. 子类继承父类，可以得到父类的全部属性和方法（除父类的构造方法）
1. Java中只有单继承，没有多重继承。多重继承会引起混乱，使得继承链过于复杂，系统难于维护。
1. Java中的多继承，可以通过接口来实现
1. java.lang.Object是所有的类的超类


## 多态（难点）

> Java引用变量，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定（即子类对象赋给父类变量），如果编译时类型和运行时类型不一致，就可能出现多态。

1. 多态定义：相同类型的(引用)变量，调用同一个方法（父类和子类都有的同名方法）时呈现出多种不同的行为特征。　　　　　　　　
当引用变量 polymophicBc 编译时类型为 BaseClass 类型，而运行时类型为 SubClass 类型，运行时调用该引用变量的方法时，其方法行为总是表现出子类 SubClass 方法的行为特征，而不是父类 BaseClass 方法的行为特征。
BaseClass polymophicBc = new SubClass(); 

2. 多态的条件：有继承关系；子类重写父类方法；父类引用变量指向子类对象。

3. Java实现多态有三个必要条件：继承、重写、向上转型 

4. 优点：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。当一个新的情景出现时,无须对现有的代码进行改动,而只需要增加一个新的类和新的同名方法。

## 类

### 局部变量和成员变量的区别

1. 成员变量直接定义在类中
2. 局部变量定义在方法中，参数上，语句中
3. 成员变量在这个类中有效
4. 局部变量只在自己所属的大括号中内有效，大括号结束，局部变量失去作用域
5. 成员变量定义在堆内存中，随着对象的产生而存在，消失而消失
6. 局部存在于栈内存中，随着所属区域的运行而存在，结束而释放

### 成员变量和静态变量的区别

1. 成员变量所属于对象，所以也称为实例变量。
2. 静态变量所属于类，所以也称为类变量
3. 成员变量存在于堆内存中。
4. 静态变量存在于方法区中。
5. 成员变量随着对象的创建而存在，随着对象被收回而消失。
6. 静态成员随着类的加载而存在，随着类的消失而消失
7. 成员变量只能被对象所调用
8. 静态变量可以被对象调用，也可以被类名调用
9. 成员变量可以称为对象的特有数据，静态变量称为对象的共享数据


### 创建一个对象的过程

1. 将硬盘中指定位置的Person.class文件加载进内存中
2. 执行main方法时，在栈内存中开辟了main的空间（压栈-进栈），然后在main方法的栈区分配了一个变量P。
3. new。在堆内存中开辟了一个实体空间，分配了一个内存首地址。
4. 在该实体空间中进行属性的空间分配，并进行了默认初始化。
5. 对空间中的属性进行显示初始化
6. 进行实体的构造代码块初始化
7. 调用该实体对应的构造函数，进行构造函数初始化
8. 将首地址赋值给p，p变量就引用了该实体。（指向了该对象）

## 接口，抽象方法

1. 接口：抽象方法的集合，完全抽象
   1. 接口只是一个抽象方法声明和静态不能被修改的数据的集合
    
2. 抽象类：抽象和实现都有
   1. 被abstract修饰的方法是抽象方法，抽象方法没有方法体。修饰符 abstract 返回值类型 函数名();抽象方法的修饰符只能用public或者protected或者没有修饰
   2. 抽象类不能被实例化，但是可以定义一个抽象类的对象变量，这个变量可以引用非抽象子类的对象

3. 不同
   1. 接口可以多实现，而抽象类只能单继承
   2. 抽象类可以有非抽象的方法和构造方法、变量，但是接口只能有抽象方法，静态常量。

4. 相同
   1. 无论接口还是抽象类，都无法直接实例化
   2. 接口和抽象类都必须实现其中的所有方法

---
**参考链接**

1. [面向对象总结](https://segmentfault.com/a/1190000014454244#articleHeader6)
2. [面向对象概念](https://github.com/FatliTalk/blog/issues/34)